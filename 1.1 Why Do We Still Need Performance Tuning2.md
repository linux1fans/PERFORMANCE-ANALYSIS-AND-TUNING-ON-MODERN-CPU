|   版本   |       实现方式        |  绝对加速比  |  相对加速比  |
|:-------:|:-------------------:|:----------:|:----------:|
|    6    |  加上向量化        |   23,224   |    3.5     |
|    7    |  加上AVX指令集     |   62,806   |    2.7     |


以下是阻止系统默认实现最佳性能的一些最重要因素：

## 1. CPU限制
很容易问："为什么硬件不能解决我们所有的问题呢？" 现代CPU以惊人的速度执行指令，并且每一代都在不断改进。但是，如果用于执行任务的指令不是最优的甚至是冗余的，处理器也无能为力。处理器不能将次优代码神奇地转换为性能更好的代码。例如，如果我们使用冒泡排序^(4)算法实现排序，CPU不会尝试识别并使用更好的替代算法，比如快速排序^(5)。它将盲目执行它被告知的指令。

## 2. 编译器限制
"但是编译器不应该解决我们所有的问题吗？为什么编译器不能解决一切问题呢？" 的确，现如今的编译器非常智能，但仍然可能生成次优的代码。编译器擅长消除冗余工作，但当涉及到更复杂的决策，如函数内联、循环展开等时，它们可能无法生成最佳的代码。例如，在是否应该始终将函数内联到调用它的位置这个问题上，并没有二进制的“是”或“否”答案。它通常取决于许多因素，编译器应该考虑这些因素。通常，编译器依赖于复杂的成本模型和启发式算法，这些模型和算法可能对每种可能的情况都不适用。此外，编译器不能执行优化，除非它们确定安全，并且不会影响生成的机器代码的正确性。对于编译器开发人员来说，确保特定优化在所有可能的情况下生成正确的代码可能非常困难，所以他们通常必须保守并避免执行某些优化^(6)。最后，编译器通常不会转换程序使用的数据结构，这些数据结构在性能方面也非常重要。

## 3. 算法复杂度分析限制
开发人员经常过分关注算法的复杂度分析，导致他们选择具有最佳算法复杂度的流行算法，即使对于给定问题来说它可能不是最高效的。考虑两种排序算法InsertionSort^(7)和QuickSort，后者在平均情况下在Big O表示法方面明显优于前者：InsertionSort是O(N^2)，而QuickSort只有O(N log N)。然而，对于相对较小的^(8)N，InsertionSort的性能优于QuickSort。复杂度分析不能考虑各种算法的优化和实际执行情况，因此在选择算法时还需要综合考虑其他因素。

大小，插入排序的性能超过了快速排序。复杂度分析无法考虑各种算法的分支预测和缓存效果，因此它们将这些效果封装在隐含常量C中，有时这会对性能产生重大影响。盲目地相信Big O表示法，而不在目标工作负载上进行测试，可能会使开发人员走上错误的道路。因此，并不是针对某个特定问题最知名的算法在实践中对于每种可能的输入都是最高效的。

上述的限制为我们调整软件性能留下了空间，以实现其最大潜力。

4. [BubbleSort算法](https://en.wikipedia.org/wiki/Bubble_sort)
5. [QuickSort算法](https://en.wikipedia.org/wiki/Quicksort)
6. 这当然适用于浮点运算的顺序。
7. [InsertionSort算法](https://en.wikipedia.org/wiki/Insertion_sort)
8. 通常在7到50个元素之间


