
首先，我们想到的一个选择是：让人类来查看图表并比较结果。但很快我们就会意识到，我们希望尽快摆脱这个选项。人们往往很快失去注意力，可能会错过回归问题，尤其是在像图3所示的嘈杂图表上。人类可能会注意到发生在8月5日左右的性能回归，但人类是否能够检测到后来的回归并不明显。除了容易出错之外，让人类参与其中还是一项耗时且乏味的工作，需要每天进行。


![Figure 3: 四个测试的性能趋势图，显示了8月5日性能略有下降（数值越高表示性能越好）。© 图片来源：[Daly et al., 2020]](pic_3.jpg)

第二个选项是采用简单的阈值。相对于第一个选项，它要好一些，但仍然有自己的缺点。性能测试的波动是不可避免的：有时，即使是一个无害的代码更改[^26]也可能引发基准测试中的性能变化。选择合适的阈值非常困难，也不能保证虚警和漏警率低。将阈值设置得太低可能会导致分析一系列不是由源代码更改引起而是由某些随机噪声引起的小的回归。将阈值设置得太高可能会导致过滤掉真正的性能回归。小的变化可能会逐渐积累成较大的回归，而这可能被忽视[^27]。从图3可以看出，阈值需要针对每个测试进行调整。对于绿色（上线）测试可能适用的阈值未必同样适用于紫色（下线）测试，因为它们具有不同级别的噪声。一个例子是LUCI[^28]，这是Chromium项目的一部分，它是一个需要为每个测试设置明确阈值以便警报回归的CI系统。

最近的一种识别性能回归的方法是[Daly et al., 2020]提出的。MongoDB开发人员实施了变点分析，用于识别其数据库产品中不断演化的代码库中的性能变化。根据[Matteson and James, 2014]，变点分析是检测时间顺序观测中分布变化的过程。MongoDB开发人员利用了一种名为“E-Divisive means”的算法，通过分层选择将时间序列分割成簇的分布变化点。他们的开源CI系统名为Evergreen[^29]，它将这个算法应用于显示图表上的变化点并打开Jira工单。关于这个自动化性能测试系统的更多细节可以在[Ingo and Daly, 2020]中找到。

另一个有趣的方法是在[Alam et al., 2019]中提出的。这篇论文的作者提出了AutoPerf，它利用硬件性能计数器（PMC，参见3.9.1节）来诊断修改后程序中的性能回归问题。首先，它基于从原始程序收集到的PMC配置文件数据学习了修改后函数的性能分布。然后，根据从修改后程序收集到的PMC配置文件数据，它检测性能的偏差作为异常。AutoPerf展示了这种设计可以有效地诊断一些最复杂的软件性能错误，比如那些隐藏在并行程序中的错误。

[^26]以下文章显示，改变函数的顺序或删除无用的函数可能会导致性能变化：[Code_alignment_issues](https://easyperf.net/blog/2018/01/18/Code_alignment_issues)。

[^27]例如，假设你有一个2%的阈值。如果你有两个连续的1.5%的回归，它们都将被过滤掉。但在两天的时间里，性能回归将累积到3%，这超过了阈值。

[^28] LUCI - [https://chromium.googlesource.com/chromium/src.git/+/master/docs/tour_of_luci_ui.md](https://chromium.googlesource.com/chromium/src.git/+/master/docs/tour_of_luci_ui.md)

[^29] Evergreen - [https://github.com/evergreen-ci/evergreen](https://github.com/evergreen-ci/evergreen).

